#!/usr/bin/env python
from leakcheck import LeakCheckAPI
import hashlib
import argparse
import json

if __name__ == '__main__':
	'''
	Initialize API
	'''
	api = LeakCheckAPI()

	parser = argparse.ArgumentParser(description='CLI version of LeakCheck API (v{}). Licensed under MIT license'.format(api.getVersion()))
	
	parser.add_argument('--key', help='Set an API key (taken from config by default)')
	parser.add_argument('-m', action='store_true', help='Use mirror (leakcheck.io instead of leakcheck.net, default: False)')
	parser.add_argument('--proxy', default='', help='Set proxy (supported: HTTP/HTTPS/SOCKS4/SOCKS5, default: empty)')
	parser.add_argument('--endpoint', default='/', help='Set an endpoint (default: /)')
	parser.add_argument('--type', default='auto', help='Set a type of the query (default: auto)')
	parser.add_argument('query', help='What are we going to search?')
	parser.add_argument('-lo', action='store_true', help='Print lines/sources only (useful if you process them later or save, default: False)')
	parser.add_argument('-p', action='store_true', help='Lookup privately (hashes data with SHA256, then truncates hash to 24 characters; works for email, pass_email only, default: False)')
	
	args = parser.parse_args()

	'''
	Some bindings
	'''
	if args.key is not None:
		api.set_key(args.key)

	if args.m == True:
		api.use_mirror()

	api.set_proxy(args.proxy)
	api.set_endpoint(args.endpoint)

	'''
	Private lookup
	'''
	if args.p == True:
		assert(args.type in ["email", "pass_email"]), "You are going to make a private lookup, but type you selected is unsupported"
		api.set_query(hashlib.sha256(args.query.encode()).hexdigest()[:24])
		api.set_type({'email': 'hash', 'pass_email': 'phash'}[args.type])
		api.set_endpoint("/")
	else:
		api.set_query(args.query)
		api.set_type(args.type)

	'''
	Print lines only
	'''
	if args.endpoint != '/hasbreached' and args.lo == True:
		for row in api.lookup():
			print(row[{'/': 'line', '/public': 'name'}[args.endpoint]])
	else:
		print(json.dumps(api.lookup(), indent=4))